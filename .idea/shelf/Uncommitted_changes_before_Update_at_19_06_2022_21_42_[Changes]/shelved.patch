Index: de.hshl.uc/src/user_interface/mainWindow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import threading\r\n\r\nimport cv2\r\nimport numpy as np\r\nimport pytz\r\nimport qimage2ndarray as qimage2ndarray\r\nfrom PyQt5.QtCore import QThread, pyqtSignal, pyqtSlot, QRect, QMutex\r\nfrom PyQt5.QtGui import QPixmap, QFont, QMovie\r\nfrom PyQt5.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QApplication, QLabel, QGridLayout\r\nfrom PyQt5.QtWidgets import QMessageBox, QStackedLayout, \\\r\n    QHBoxLayout\r\n\r\n# from Socket.local.localClient import local_client\r\nfrom pyqtgraph import Qt\r\n\r\nfrom Socket.online.onlineClient import local_client\r\nfrom Socket.online.Chat.Chat_Client_V01 import chat_client\r\nfrom model.camera import Camera\r\nfrom recognition.gesture_detector import gesture_detector\r\nfrom recognition.hand_detector import hand_detector\r\nfrom user_interface.pongScreen import pongScreen\r\nfrom user_interface.startWindow import startWindow\r\n\r\nfrom recognition.body_detector import body_detector\r\nfrom datetime import datetime\r\nimport time\r\nimport requests\r\n\r\n\r\nclass bcolors:\r\n    HEADER = '\\033[95m'\r\n    OKBLUE = '\\033[94m'\r\n    OKCYAN = '\\033[96m'\r\n    OKGREEN = '\\033[92m'\r\n    WARNING = '\\033[93m'\r\n    FAIL = '\\033[91m'\r\n    ENDC = '\\033[0m'\r\n    BOLD = '\\033[1m'\r\n    UNDERLINE = '\\033[4m'\r\n\r\n\r\n\r\nclass VideoThread(QThread):\r\n    ar = []\r\n    change_ab_signal = pyqtSignal(int)\r\n    change_pixmap_signal = pyqtSignal(np.ndarray)\r\n    update_label_signal = pyqtSignal(int)\r\n    update_ball_signal = pyqtSignal(int, int)\r\n    update_player_2 = pyqtSignal(int)\r\n    starte_receive_loop = pyqtSignal(local_client)\r\n    update_tor = pyqtSignal()\r\n    counter = int(1)\r\n    client = local_client()\r\n\r\n    def __init__(self, camera, hand_detector):\r\n        super(VideoThread, self).__init__()\r\n        self.ser = False\r\n        self.state = 0\r\n        self._mutex = QMutex()\r\n        self.serialEnabled = True\r\n        self.camera = camera\r\n        self.hand_detector = hand_detector\r\n        hd = self.hand_detector\r\n        gd = gesture_detector()\r\n\r\n    def start_receive(self):\r\n        self.client.receive()\r\n        print(\"THEADING!!!!!\")\r\n\r\n    def videoLoop(self, Player):\r\n        bX = 0\r\n        bY = 0\r\n        speedX = 10\r\n        speedY = 0\r\n        hd = hand_detector()\r\n        gd = gesture_detector()\r\n        lmList = []\r\n        self.hand_detector.handlist = lmList\r\n        video = 'hands.mp4'\r\n        self.camera = Camera(0)\r\n        self.camera.initialize()\r\n        # Left or Right\r\n        #Player = 'Left'  # input('Player: ')\r\n\r\n        #self.client.player = Player\r\n\r\n        # rThread.start()\r\n        # self.starte_receive_loop.emit(self.client)\r\n        # capture from web cam\r\n        # self.update_chat_signal.emit()\r\n        #self.client.sendReady('Left')\r\n        # self.client.sendcoordinate('Left', 111)\r\n\r\n        print(\"SRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\")\r\n        while True:\r\n            success, img = self.camera.cap.read()\r\n            # img.flags.writeable = False\r\n            print(self.client.canStart, '2222222222222')\r\n\r\n            #if self.client.canStart == True:\r\n            if not self.client.ballcoords.__getitem__(0) == 1011100 and not self.client.ballcoords.__getitem__(\r\n                    0) == 1011101:\r\n                self.update_ball_signal.emit(self.client.ballcoords.__getitem__(0),\r\n                                             self.client.ballcoords.__getitem__(1))\r\n            if success:\r\n\r\n                # self.client.canStart = False\r\n                self.change_ab_signal.emit(1)\r\n\r\n                # init Hand detector\r\n                # hd.findHands(img)\r\n                img = cv2.resize(img, (1280, 750), fx=0, fy=0, interpolation=cv2.INTER_CUBIC)\r\n                img_proc = self.hand_detector.find_hands_on_image(self.hand_detector, img)\r\n                lmList = self.hand_detector.handlist\r\n\r\n                # fps = self.camera.cap.get(cv2.CAP_PROP_FPS)\r\n                # cv2.putText(img_proc, str(int(fps)), (10, 70), cv2.FONT_HERSHEY_PLAIN, 3, (255, 0, 255), 3)\r\n                # print(lmList)\r\n                gd.writeLmList(lmList)\r\n                # gd.print()\r\n                # cv2.imshow('Test', img)\r\n                self.change_pixmap_signal.emit(img_proc)\r\n\r\n                # Game Loop\r\n                bX += 1 + speedX\r\n                bY += 1 + speedY\r\n                print(bcolors.OKBLUE, self.client.test, \" TorLinks\", bcolors.ENDC)\r\n                # Bewege ball\r\n                print(bcolors.FAIL, self.client.ballcoords.__getitem__(0), bcolors.ENDC)\r\n\r\n                # Tor L\r\n\r\n\r\n                # self.update_ball_signal.emit(500, 500)\r\n\r\n                # To Do send to server:\r\n\r\n                #if not lmList:\r\n                #    print()\r\n                #else:\r\n                print(bcolors.FAIL, self.client.TempChatList,\r\n                      \"EMITYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\",\r\n                      bcolors.ENDC)\r\n                # self.update_chat.emit()\r\n                if not self.client.TempChatList:\r\n                    print(bcolors.FAIL,\r\n                          \"EMITYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY\",\r\n                          bcolors.ENDC)\r\n\r\n                # Send Tupel\r\n                print('Send Coordinates form Main Window')\r\n                if len(lmList):\r\n                    self.client.sendcoordinate(Player, lmList[0].__getitem__(2))\r\n                print('Send Coordinates form Main Window 2')\r\n                # print(\"Player:  \", self.client.TempTupel.__getitem__(0))\r\n\r\n                if self.client.TempTupel.__getitem__(0) == 'Left':\r\n                    self.update_label_signal.emit(self.client.TempTupel.__getitem__(1))\r\n                else:\r\n                    self.update_player_2.emit(self.client.TempTupel.__getitem__(1))\r\n                print()\r\n                # print(client.y)\r\n                # To Do receive Coordinate\r\n\r\n                # Updates the label\r\n\r\n\r\n    # Camera Loop\r\n    def run(self):\r\n        Player = 'Right'  # input('Player: ')\r\n\r\n        self.client.player = Player\r\n        rThread = threading.Thread(target=self.start_receive, args=())\r\n        #rThread.start()\r\n        #self.client.receive()\r\n        self.client.sendReady('Right')\r\n        while True:\r\n            if self.client.canStart == True:\r\n                print(bcolors.WARNING, \"Starte VideoLoop\", bcolors.ENDC)\r\n                self.videoLoop(Player)\r\n\r\n\r\n\r\n\r\nclass StartWindow(QMainWindow):\r\n    window_title = \"\"\r\n\r\n    def __init__(self, camera=None, hand_detector=None, local_cL=None):\r\n        super().__init__()\r\n        self.scoreLeftCounter = 0\r\n        self.scoreRightCounter = 0\r\n        self.width = 1280\r\n        self.height = 750\r\n        self.window_title = 'start'\r\n        self.fontA = QFont(\"Josefin Sans Medium\", 24)\r\n        self.fontB = QFont(\"Josefin Sans Medium\", 100)\r\n        self.fontC = QFont(\"Josefin Sans Medium\", 40)\r\n        self.bX = 0\r\n        self.bY = 0\r\n        self.positive = True\r\n        self.counter = 0\r\n        self.camera = camera\r\n        self.hand_detector = hand_detector\r\n        self.local_cL = local_cL\r\n        self.display_width = self.width\r\n        self.display_height = self.height\r\n        self.setWindowTitle('Projekt: Ubi')\r\n        self.setMinimumSize(self.width, self.height)\r\n        self.setMaximumSize(self.width, self.height)\r\n        self.loading = QMovie('Tools/loading-circle.gif')\r\n        # Create Video Thread\r\n        self.thread = BackgroundFeed(self.camera, self.hand_detector)\r\n        # Update Label\r\n        self.thread.change_pixmap_signal.connect(self.update_image)\r\n        # Updates the Cursor\r\n        self.thread.change_cursor_position.connect(self.update_cursor)\r\n        # Debug\r\n        self.thread.change_ab_signal.connect(self.update_chat_debug)\r\n        self.chat_client = self.thread.client\r\n        print(self.chat_client)\r\n        self.thread.change_lc.connect(self.start_thread_receive)\r\n        # Start Thread\r\n        self.thread.update_infolabel.connect(self.update_infolabel)\r\n        self.thread.start()\r\n        # Chat\r\n        self.globalChat = []\r\n\r\n        self.isPause = False\r\n        self.pauseThread = PauseThread()\r\n\r\n        # self.pixmap_item = QPixmap()\r\n\r\n        # Central Widget\r\n        self.central_widget = QWidget()\r\n        self.layout_for_wids = QStackedLayout()\r\n\r\n        self.startWindow = startWindow()\r\n        self.pongWindow = pongScreen()\r\n\r\n        # Widgets\r\n\r\n        # self.wid_start.setStyleSheet(\"\"\"background: blue;\"\"\")\r\n\r\n        # Layout Container for Widgets and Buttons\r\n        self.layout_for_wids.addWidget(self.startWindow)\r\n        self.layout_for_wids.addWidget(self.pongWindow)\r\n\r\n        # Debug\r\n\r\n        # Adds the eleemnets to the main viewport\r\n        grid_layout = QGridLayout()\r\n        self.mid_label = QLabel()\r\n        self.mid_label.setText(\"TRUE\")\r\n        self.startWindow.layout = QVBoxLayout(self.startWindow)\r\n        self.startWindow.layout.addWidget(self.startWindow.imageLabel)\r\n\r\n        self.startWindow.imageLabel.setLayout(grid_layout)\r\n\r\n\r\n        #self.startWindow.imageLabel.layout.addWidget(self.startWindow.info_Label_Container)\r\n\r\n        self.startWindow.info_Label_Container.layout = QHBoxLayout(self.startWindow.info_Label_Container)\r\n        self.startWindow.info_Label_Container.layout.addWidget(self.startWindow.date_label)\r\n        self.startWindow.info_Label_Container.layout.addWidget(self.startWindow.clock_temp_vbox)\r\n        self.startWindow.info_Label_Container.layout.addWidget(self.startWindow.fact_label)\r\n        grid_layout.addWidget(self.startWindow.info_Label_Container, 0, 0, 1, 3)\r\n\r\n        #self.startWindow.imageLabel.layout.addWidget(self.startWindow.mid_label_container)\r\n        #self.startWindow.imageLabel.layout.addWidget(self.startWindow.button_Play)\r\n\r\n        grid_layout.addWidget(self.startWindow.button_Play, 1, 0, -1, 1)\r\n        grid_layout.addWidget(self.startWindow.outer_chat_v_label, 1, 2, -1, 1)\r\n        grid_layout.addWidget(self.startWindow.cursor, 1, 0)\r\n        self.startWindow.loading_label.setVisible(False)\r\n\r\n        #self.startWindow.imageLabel.layout.addWidget(self.startWindow.cursor)\r\n\r\n        #self.startWindow.imageLabel.layout.addWidget(self.mid_label)\r\n\r\n        self.pongWindow.layout = QVBoxLayout(self.pongWindow)\r\n        self.pongWindow.layout.addWidget(self.pongWindow.imageLabel)\r\n        self.pongWindow.layout.addWidget(self.pongWindow.button_movie)\r\n        #self.pongWindow.setMinimumSize(1920, 1080)\r\n        self.central_widget.setLayout(self.layout_for_wids)\r\n\r\n\r\n        # self.layout = QVBoxLayout(self.central_widget)\r\n        # self.layout.addWidget(self.imageLabel)\r\n        self.setCentralWidget(self.central_widget)\r\n        # Connects the button actions\r\n        self.pongWindow.button_movie.clicked.connect(self.start_movie)\r\n        # self.startWindow.button_Play.clicked.connect(self.start_Game)\r\n        #self.pongWindow.imageLabel1.setGeometry(QRect(10, 200, 10, 400))\r\n        #self.pongWindow.imageLabel2.setFixedWidth(10)\r\n        #self.pongWindow.imageLabel2.move(400, 222)\r\n        #self.pongWindow.imageLabel2.setAlignment(Qt.AlignCenter)\r\n        #self.start_Game()\r\n\r\n\r\n\r\n    def start_Game(self):\r\n        print(\"Test\")\r\n        self.camera.close_camera()\r\n        if self.window_title == 'start':\r\n            print(\"True\")\r\n            self.window_title = 'game'\r\n            self.startWindow.hide()\r\n            self.pongWindow.show()\r\n            #ToDo: Implement direct play start!\r\n            self.pongWindow.button_movie.click()\r\n\r\n\r\n    def closeEvent(self, event):\r\n        reply = QMessageBox.question(self, 'Window Close', 'Are you sure you want to close the window?',\r\n                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)\r\n\r\n        if reply == QMessageBox.Yes:\r\n            self.local_cL.close_client()\r\n            event.accept()\r\n\r\n            print('Window closed')\r\n        else:\r\n            event.ignore()\r\n\r\n    # self.update_timer = QTimer()\r\n    # self.update_timer.timeout.connect(self.update_movie)\r\n\r\n    @pyqtSlot(np.ndarray)\r\n\r\n\r\n    def update_image(self, cv_img):\r\n        \"\"\"Updates the image_label with a new opencv image\"\"\"\r\n        # self.pixmap_item.fromImage(self.convert_cv_qt(cv_img))\r\n        qt_img = self.convert_cv_qt(cv_img)\r\n        self.pongWindow.imageLabel.setPixmap(QPixmap.fromImage(qt_img))\r\n        self.startWindow.imageLabel.setPixmap(QPixmap.fromImage(qt_img))\r\n        #self.startWindow.imageLabel.pixmap().scaled(1920, 1080)\r\n\r\n    def update_cursor(self, x, y):\r\n        print(x, y)\r\n\r\n        self.startWindow.cursor.move(x, y)\r\n        #self.startWindow.button_Play.move(x, y)\r\n        if self.startWindow.cursor.geometry().intersected(self.startWindow.button_Play.geometry()):\r\n            self.counter += 5\r\n            #self.startWindow.cursor.setText(str(self.startWindow.cursor.geometry().getCoords()))\r\n            #self.startWindow.button_Play.setText(str(self.startWindow.button_Play.geometry().getCoords()))\r\n            print(\"counter:\", self.counter)\r\n            self.startWindow.load(self.counter)\r\n            #self.startWindow.loading_label.setGeometry(QRect(100, 250, 250, 150))\r\n            if self.counter > 100:\r\n                #If Counter hits 60 -> the view switches to the game (Pong screen)\r\n                self.start_Game()\r\n                self.counter = 0\r\n        else:\r\n            self.startWindow.reset_load()\r\n            self.counter = 0;\r\n            #self.start_Game()\r\n            print()\r\n\r\n        #else:\r\n        #    self.startWindow.cursor.setStyleSheet('background-color: yellow')\r\n\r\n    def updatePosition(self, c):\r\n        self.pongWindow.imageLabel1.setGeometry(QRect(100, c - 100, 10, 200))\r\n        #self.pongWindow.imageLabel2.setGeometry(QRect(1240, 200, 10, 200))\r\n        # self.imageLabel2.setGeometry(QRect(1400,c-200,10,400))\r\n        print(\"Klick\")\r\n\r\n    def updatePositionPlayer2(self, y):\r\n        print(y, \" TEST\")\r\n        self.pongWindow.imageLabel2.setGeometry(QRect(1140, y - 100, 10, 200))\r\n\r\n    def updateBall(self, x, y):\r\n        self.pongWindow.bandeOben.setVisible(True)\r\n        self.pongWindow.bandeUnten.setVisible(True)\r\n        self.pongWindow.bandeOben.setGeometry(0, 0, 80, 80)\r\n        self.pongWindow.bandeUnten.setGeometry(0, 720, 80, 80)\r\n        self.pongWindow.torLeft.setVisible(True)\r\n        self.pongWindow.torRight.setVisible(True)\r\n        self.pongWindow.torLeft.setGeometry(0, 0, 80, 80)\r\n        self.pongWindow.torRight.setGeometry(1248, 0, 80, 80)\r\n\r\n        self.pongWindow.scoreLeft.setGeometry(QRect(600, 50, 10, 50))\r\n        self.pongWindow.scoreRight.setGeometry(QRect(700, 50, 10, 50))\r\n\r\n        print('Die positive Variable: ', self.positive)\r\n\r\n        # elif self.detect_collision()==False and not self.positive:\r\n        #    self.positive = True\r\n        #if self.detect_collision():\r\n        #    if self.positive:\r\n        #        self.positive = False\r\n\r\n        #    elif self.positive == False:\r\n        #        self.positive = True\r\n\r\n        #if self.positive == True:\r\n        #    self.ballMovementpositive()\r\n        #elif self.positive == False:\r\n        #    self.ballMovementnegative()\r\n\r\n\r\n        self.pongWindow.imageLabel3.setGeometry(x, y, 80, 80)\r\n        self.detect_collision()\r\n        print(bcolors.FAIL,self.pongWindow.imageLabel3.geometry().x(), \" X Coord\", bcolors.ENDC)\r\n        if self.pongWindow.imageLabel3.geometry().x() >= 850 and self.pongWindow.imageLabel3.geometry().x() <= 853:\r\n            self.updateTor()\r\n\r\n\r\n    def ballMovementpositive(self):\r\n        self.bX += 10\r\n        self.bY += 1\r\n        self.pongWindow.imageLabel3.setGeometry(self.bX, self.bY, 80, 80)\r\n\r\n    def ballMovementnegative(self):\r\n        self.bX -= 10\r\n        # self.bY -= 1\r\n        self.pongWindow.imageLabel3.setGeometry(self.bX, self.bY, 80, 80)\r\n\r\n    def detect_collision(self):\r\n        # if self.imageLabel3.geometry().center()+80 == self.imageLabel2.geometry().intersects()\r\n        if self.positive:\r\n            # Collision Paddle Right!\r\n            if self.pongWindow.imageLabel3.geometry().intersected(self.pongWindow.imageLabel2.geometry()):\r\n                print(\"INTERSECTION!\")\r\n                self.local_cL.sendCollision(\"paddleR\")\r\n                return True\r\n            # Collision Paddle Left\r\n            elif self.pongWindow.imageLabel3.geometry().intersected(self.pongWindow.imageLabel1.geometry()):\r\n                print(\"INTERSECTION!\")\r\n                self.local_cL.sendCollision(\"paddleL\")\r\n                return True\r\n            # Collision Bande Oben\r\n            elif self.pongWindow.imageLabel3.geometry().intersected(self.pongWindow.bandeOben.geometry()):\r\n                print(\"INTERSECTION!\")\r\n                self.local_cL.sendCollision(\"bandeO\")\r\n                return True\r\n            # Collision Bande Unten\r\n            elif self.pongWindow.imageLabel3.geometry().intersected(self.pongWindow.bandeUnten.geometry()):\r\n                print(\"INTERSECTION!\")\r\n                self.local_cL.sendCollision(\"bandeU\")\r\n                return True\r\n                # Collision Bande Oben\r\n            elif self.pongWindow.imageLabel3.geometry().intersected(self.pongWindow.torLeft.geometry()):\r\n                print(\"INTERSECTION!\")\r\n                #self.String(\"torL\")\r\n                self.local_cL.sendCollision(\"torL\")\r\n                #self.scoreRightCounter += 1\r\n                #self.pongWindow.scoreRight.setText(str(self.scoreRightCounter))\r\n                #time.sleep(0.5)\r\n                return True\r\n            # Collision Bande Unten\r\n            elif self.pongWindow.imageLabel3.geometry().intersected(self.pongWindow.torRight.geometry()):\r\n                print(\"INTERSECTION!\")\r\n                self.local_cL.sendCollision(\"torR\")\r\n                #self.scoreLeftCounter += 1\r\n                #self.pongWindow.scoreLeft.setText(str(self.scoreLeftCounter))\r\n                #time.sleep(0.5)\r\n                return True\r\n            else:\r\n                return False\r\n\r\n    def update_infolabel(self):\r\n        # Get Date and Time\r\n        timezone = pytz.timezone('Europe/Berlin')\r\n        now = datetime.now(timezone)\r\n        now.astimezone()\r\n        time = now.strftime(\"%H:%M\")\r\n        get_date = now.date().strftime(\"%A\")\r\n\r\n        match str(get_date):\r\n            case \"Monday\":\r\n                get_date = \"Montag\"\r\n            case \"Tuesday\":\r\n                get_date = \"Dienstag\"\r\n            case \"Wednesday\":\r\n                get_date = \"Mittwoch\"\r\n            case \"Thursday\":\r\n                get_date = \"Donnerstag\"\r\n            case \"Friday\":\r\n                get_date = \"Freitag\"\r\n            case \"Saturday\":\r\n                get_date = \"Samstag\"\r\n            case \"Sunday\":\r\n                get_date = \"Sonntag\"\r\n\r\n        self.startWindow.clock_label.setText(str(time))\r\n        self.startWindow.date_label.setText(str(get_date))\r\n\r\n    def convert_cv_qt(self, cv_img):\r\n        cv_img = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)\r\n        cv_img = qimage2ndarray.array2qimage(cv_img)\r\n        return cv_img\r\n\r\n    \"\"\"Convert from an opencv image to QPixmap\"\"\"\r\n\r\n    # rgb_image = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)\r\n    # h, w, ch = rgb_image.shape\r\n    # bytes_per_line = ch * w\r\n    # convert_to_Qt_format = QtGui.QImage(rgb_image.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)\r\n    # p = convert_to_Qt_format.scaled(self.disply_width, self.display_height, Qt.KeepAspectRatio)\r\n    def start_thread_receive(self, local_cla):\r\n        self.local_cL = local_cla\r\n\r\n    def upchatlabel(self):\r\n        self.startWindow.inner_chat_label.move(400)\r\n        self.startWindow.inner_chat_label.setText(\"TEST111111111111111111111111!\")\r\n        print(bcolors.BOLD,\"TEST111111111111111111111111!\",bcolors.ENDC)\r\n\r\n    # Only for debug!\r\n\r\n\r\n    def updateTor(self):\r\n        self.scoreRightCounter += 1\r\n        self.pongWindow.scoreRight.setText(str(self.scoreRightCounter))\r\n        print('Tor')\r\n\r\n\r\n\r\n\r\n    def update_chat_debug(self, ab):\r\n        # uses dict\r\n        self.vbar = self.startWindow.scrollArea.verticalScrollBar()\r\n        self.vbar.setValue(self.vbar.maximum())\r\n        #Debug\r\n        atuple = ('Left', 0)\r\n        if ab[0] == atuple:\r\n            print('TRUE!!!!')\r\n            print(bcolors.HEADER, ab, bcolors.ENDC)\r\n\r\n\r\n        ac = []\r\n        ac = ab\r\n        #print(ac[1].__getitem__(0))\r\n\r\n\r\n        if not ab == tuple:\r\n            if not ab[0] == atuple:\r\n\r\n                abc = {'user': 'ab'}\r\n\r\n                dicta = {}\r\n                for x in range(len(list(ac))):\r\n\r\n\r\n                    dicta = list(ac)[x].__getitem__(0)\r\n\r\n                    user = list(iter(dicta))[1]\r\n\r\n                    chat = dicta.get(user)\r\n\r\n                    if not self.globalChat.__contains__(chat):\r\n                        self.globalChat.append(chat)\r\n\r\n                a = {}\r\n                a.values()\r\n\r\n                # print(ab.index())\r\n                ele = []\r\n                # for k, v in list(ac)[0].__getitem__(1).items():\r\n\r\n                # print(k, v)\r\n\r\n                # for x in ac:\r\n                #    ele.append(x[0])\r\n                # res_list = [x[0] for x in ac]\r\n                # x = list(ac)[0].__getitem__(1).count\r\n\r\n                print(bcolors.FAIL, self.globalChat, bcolors.ENDC)\r\n\r\n                # print(bcolors.FAIL, dicta.values(), bcolors.ENDC)\r\n                # print(bcolors.FAIL, ac[1], bcolors.ENDC)\r\n                self.startWindow.inner_chat_label.setText(str(self.globalChat))\r\n                self.startWindow.inner_chat_label.setText(str(\"\\n\".join(self.globalChat)))\r\n\r\n        #self.camera.close_camera()\r\n        #self.startWindow.inner_chat_label.setText(\"TEST!\")\r\n        #self.startWindow.show()\r\n        #self.pongWindow.hide()\r\n\r\n\r\n    def start_movie(self):\r\n        self.pongWindow.button_movie.setVisible(False)\r\n        #self.pongWindow.imageLabel2.setGeometry(QRect(1240, 100, 10, 200))\r\n        # create the video capture thread\r\n        self.thread = VideoThread(self.camera, self.hand_detector)\r\n        # self.thread.client.client.close()\r\n        self.local_cL = self.thread.client\r\n        print(self.local_cL)\r\n        #self.thread.starte_receive_loop.connect(self.start_thread_receive)\r\n        # connect its signal to the update_image slot\r\n        self.thread.change_pixmap_signal.connect(self.update_image)\r\n        self.thread.update_label_signal.connect(self.updatePosition)\r\n        self.thread.update_ball_signal.connect(self.updateBall)\r\n        #self.thread.update_chat_signal.connect(self.upchatlabel)\r\n        self.thread.update_tor.connect(self.updateTor)\r\n        self.thread.update_player_2.connect(self.updatePositionPlayer2)\r\n\r\n        #self.update_chat_debug()\r\n\r\n        # start the thread\r\n        self.thread.start()\r\n        # self.thread1.start()\r\n        # self.update_timer.start(30)\r\n\r\nclass msg(object):\r\n    def __init__(self, message):\r\n        self.message = message\r\n\r\n\r\n\r\n\r\nclass BackgroundFeed(QThread):\r\n    a = \"a\"\r\n    #change_ab_signal = pyqtSignal(str)\r\n    change_ab_signal = pyqtSignal(object)\r\n    change_pixmap_signal = pyqtSignal(np.ndarray)\r\n    change_cursor_position = pyqtSignal(int, int)\r\n    update_infolabel = pyqtSignal()\r\n    ## LC\r\n    change_lc = pyqtSignal(chat_client)\r\n    counter = int(1)\r\n\r\n    client = chat_client()\r\n\r\n\r\n\r\n    def start_receive(self):\r\n        self.client.receive()\r\n        print(\"THEADING!!!!!\")\r\n\r\n    def __init__(self, camera, hand_detector):\r\n        super().__init__()\r\n        self.camera = camera\r\n        self.hand_detector = hand_detector\r\n        hd = self.hand_detector\r\n        gd = gesture_detector()\r\n\r\n    # Camera Loop\r\n    def run(self):\r\n        print(\"Video Started\")\r\n        hd = hand_detector()\r\n        gd = gesture_detector()\r\n        lmList = []\r\n        # rThread.start()\r\n        # self.starte_receive_loop.emit(self.client)\r\n        # capture from web cam\r\n        Player = 'Left'  # input('Player: ')\r\n        bodyDetector = body_detector()\r\n\r\n        self.client.player = Player\r\n        self.client.sendcoordinate(Player, 100)\r\n        rThread = threading.Thread(target=self.start_receive, args=())\r\n\r\n\r\n        while True:\r\n\r\n            self.client.sendcoordinate(Player, 100)\r\n            success, img = self.camera.cap.read()\r\n            # img.flags.writeable = False\r\n            if success:\r\n                self.update_infolabel.emit()\r\n                print(bcolors.OKCYAN,'!!@@',self.client.TempChatList,bcolors.ENDC)\r\n                self.change_ab_signal.emit(self.client.TempChatList)\r\n                # init Hand detector\r\n                # hd.findHands(img)\r\n                img = cv2.resize(img, (1280, 750), fx=0, fy=0, interpolation=cv2.INTER_CUBIC)\r\n                img_proc = self.hand_detector.find_hands_on_image(self.hand_detector, img)\r\n                lmList = self.hand_detector.handlist\r\n                # print(lmList)\r\n                gd.writeLmList(lmList)\r\n                if len(lmList) !=0:\r\n                    x = int(lmList[0].__getitem__(1))\r\n                    y = int(lmList[0].__getitem__(2))\r\n                    #print(x, \"_\", y)\r\n                    # Updates Cursor Coordinate from the lmList hands points\r\n                    # Tracks always the middle point\r\n                    self.change_cursor_position.emit(x, y)\r\n                # gd.print()\r\n                # cv2.imshow('Test', img)\r\n                body_image_black = bodyDetector.findPose(img_proc)\r\n                body_image_black = cv2.resize(body_image_black, (1280, 750), fx=0, fy=0, interpolation=cv2.INTER_CUBIC)\r\n                #img_proc = self.hand_detector.find_hands_on_image(self.hand_detector, body_image_black)\r\n                self.change_pixmap_signal.emit(body_image_black)\r\n\r\n\r\n\r\nclass PauseThread(QThread):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n    def run(self):\r\n        time.sleep(0.1)\r\n        return False\r\n\r\nif __name__ == '__main__':\r\n    app = QApplication([])\r\n    window = StartWindow()\r\n    window.setWindowTitle('Project: UBI')\r\n    window.setBaseSize(2400, 1444)\r\n    window.show()\r\n    app.exit(app.exec_())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/de.hshl.uc/src/user_interface/mainWindow.py b/de.hshl.uc/src/user_interface/mainWindow.py
--- a/de.hshl.uc/src/user_interface/mainWindow.py	(revision f60f55b65de3e5a25c1df81acaf2ae03c3ade0c9)
+++ b/de.hshl.uc/src/user_interface/mainWindow.py	(date 1655666854833)
@@ -167,13 +167,13 @@
 
     # Camera Loop
     def run(self):
-        Player = 'Right'  # input('Player: ')
+        Player = 'Left'  # input('Player: ')
 
         self.client.player = Player
         rThread = threading.Thread(target=self.start_receive, args=())
         #rThread.start()
         #self.client.receive()
-        self.client.sendReady('Right')
+        self.client.sendReady('Left')
         while True:
             if self.client.canStart == True:
                 print(bcolors.WARNING, "Starte VideoLoop", bcolors.ENDC)
@@ -379,7 +379,7 @@
         self.pongWindow.torLeft.setVisible(True)
         self.pongWindow.torRight.setVisible(True)
         self.pongWindow.torLeft.setGeometry(0, 0, 80, 80)
-        self.pongWindow.torRight.setGeometry(1248, 0, 80, 80)
+        self.pongWindow.torRight.setGeometry(1250, 0, 80, 80)
 
         self.pongWindow.scoreLeft.setGeometry(QRect(600, 50, 10, 50))
         self.pongWindow.scoreRight.setGeometry(QRect(700, 50, 10, 50))
Index: de.hshl.uc/src/user_interface/startWindow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nfrom PyQt5 import QtCore\r\nfrom PyQt5.QtCore import Qt\r\nfrom PyQt5.QtGui import QFont, QPalette\r\nfrom PyQt5.QtWidgets import QWidget, QLabel, QVBoxLayout, QHBoxLayout, QPushButton, QSizePolicy, QStackedLayout\r\nfrom pyqtgraph.Qt import QtGui\r\nfrom datetime import datetime\r\nimport pytz\r\nimport json\r\nfrom requests import request\r\n\r\n\r\nfrom user_interface.Tools.Cursor import Cursor\r\nfrom user_interface import global_specs\r\n\r\n\r\nclass startWindow(QWidget):\r\n    DEFAULT_WIDTH = 250\r\n    DEFAULT_HEIGTH = 150\r\n    def __init__(self):\r\n        super().__init__()\r\n        # Change the desired Resolution!\r\n        # Default:\r\n        #         w: 1920\r\n        #         h: 1080\r\n        # Beamer in use:\r\n        #         w: 1280\r\n        #         h: 750\r\n\r\n        width = 1280\r\n        height = 750\r\n        self.fontA = QFont(\"Josefin Sans Medium\", 14)\r\n        self.fontB = QFont(\"Josefin Sans Medium\", 40)\r\n        self.fontC = QFont(\"Josefin Sans Medium\", 20)\r\n        # Adds an image lable to the background\r\n        self.imageLabel = QLabel()\r\n        self.imageLabel.setAutoFillBackground(True)\r\n        self.setMaximumSize(width, height)\r\n        self.setMaximumSize(width, height)\r\n        self.imageLabel.setAlignment(Qt.AlignCenter)\r\n        self.imageLabel.setBackgroundRole(QPalette.Base)\r\n        self.imageLabel.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)\r\n        self.imageLabel.setScaledContents(True)\r\n        # Adds the cursor\r\n        self.cursor = Cursor()\r\n        # Info Label\r\n        self.info_Label_Container = QLabel()\r\n        self.info_Label_Container.setStyleSheet(\r\n            \"margin: 20px 40px; border-radius: 25px; background: #8BC1E9; color: black;\")\r\n        # self.info_Label_Container.setMaximumHeight(400)\r\n        self.info_Label_Container.setFont(self.fontA)\r\n        # self.info_Label_Container.setMaximumSize(100, 400)\r\n        self.info_Label_Container.setAutoFillBackground(True)\r\n        # self.info_Label_Container.setStyleSheet(\"\"\"background: #ebef00;\"\"\")\r\n        # date and temp vBox\r\n        self.clock_temp_vbox = QLabel()\r\n        self.clock_temp_vbox.layout = QVBoxLayout(self.clock_temp_vbox)\r\n\r\n\r\n\r\n        # Get Date and Time\r\n        timezone = pytz.timezone('Europe/Berlin')\r\n        now = datetime.now(timezone)\r\n        now.astimezone()\r\n        time = now.strftime(\"%H:%M\")\r\n        get_date = now.date().strftime(\"%A\")\r\n\r\n        match str(get_date):\r\n            case \"Monday\":\r\n                get_date = \"Montag\"\r\n            case \"Tuesday\":\r\n                get_date = \"Dienstag\"\r\n            case \"Wednesday\":\r\n                get_date = \"Mittwoch\"\r\n            case \"Thursday\":\r\n                get_date = \"Donnerstag\"\r\n            case \"Friday\":\r\n                get_date = \"Freitag\"\r\n            case \"Saturday\":\r\n                get_date = \"Samstag\"\r\n            case \"Sunday\":\r\n                get_date = \"Sonntag\"\r\n\r\n        # Date Label\r\n        self.date_label = QLabel()\r\n        self.date_label.setText(str(get_date))\r\n        self.date_label.setFont(self.fontA)\r\n        # Clock\r\n        self.clock_label = QLabel()\r\n        self.clock_label.setText(str(time))\r\n        self.clock_label.setAlignment(QtCore.Qt.AlignCenter)\r\n        # self.clock_label.setMinimumWidth(400)\r\n        self.clock_label.setFont(self.fontB)\r\n        self.clock_label.setStyleSheet(\"margin-bottom: 0px; color: white\")\r\n\r\n        api_key = \"34b02d4ce2b0b1319d917fa7d34a2f92\"\r\n        base_url = \"https://api.openweathermap.org/data/2.5/weather?q=\"\r\n        city_name = \"lippstadt\"\r\n\r\n        self.complete_url = base_url + city_name + \"&appid=\" + api_key\r\n        response = requests.get(self.complete_url)\r\n        data = response.json()\r\n\r\n        # -273.15 weil Kelvin zu Celsius\r\n        print(\"hier muss es hin: \" + str(int(data[\"main\"][\"temp\"] - (273.15))))\r\n\r\n\r\n\r\n        # Temp\r\n        self.temp_label = QLabel()\r\n        self.temp_label.setText(str(int(data[\"main\"][\"temp\"] - (273.15))) + \"°C\")\r\n        self.temp_label.setAlignment(QtCore.Qt.AlignCenter)\r\n        self.temp_label.setFont(self.fontC)\r\n        self.temp_label.setStyleSheet(\"margin-top: 0px; color: white\")\r\n        # Fact Label\r\n        self.fact_label = QLabel()\r\n        self.fact_label.setText(\r\n            \"Lorem ipsum dolor sit amet, \\nconsetetur sadipscing elitr, \\nsed diam nonumy eirmod tempor invidunt \\nut labore et dolore magna aliquyam \\nerat, sed diam voluptua.\")\r\n        self.fact_label.setFont(self.fontA)\r\n        # Adds Clock and Temp to the vbox\r\n        self.clock_temp_vbox.layout.addWidget(self.clock_label)\r\n        self.clock_temp_vbox.layout.addWidget(self.clock_label)\r\n        self.clock_temp_vbox.layout.addWidget(self.temp_label)\r\n        self.clock_temp_vbox.setMinimumWidth(800)\r\n        # self.clock_temp_vbox.setStyleSheet(\"overflow: hidden;border-radius: 25px; background: #F7AF9D; color: black;\")\r\n\r\n        # Hbox\r\n        self.mid_label_container = QLabel()\r\n        self.mid_label_container.layout = QHBoxLayout(self.mid_label_container)\r\n        self.mid_label_container.setMaximumHeight(100)\r\n        # inner vbox\r\n        self.inner_vbox_label_container = QLabel()\r\n        self.inner_vbox_label_container.setMaximumSize(200, 200)\r\n        self.inner_vbox_label_container.layout = QVBoxLayout(self.inner_vbox_label_container)\r\n        self.inner_vbox_label_container.setAlignment(QtCore.Qt.AlignCenter)\r\n        # Adds Buttons to the inner box\r\n        self.button_Opinion = QPushButton('Meinungsumfrage', self.inner_vbox_label_container)\r\n        self.button_Opinion.setStyleSheet(\r\n            \"margin-left: 20px 40px; background-color: #B28BBC; border-style: thin; border-color: black; border-width: 5px; border-radius: 24px;\")\r\n        self.button_Opinion.setMinimumSize(200, 200)\r\n        self.button_Opinion.setMaximumSize(200, 200)\r\n        self.button_Opinion.setFont(self.fontA)\r\n        #self.button_Play = QPushButton('Spielesammlung', self.inner_vbox_label_container)\r\n        self.buttonWidgetContainer = QLabel()\r\n        self.buttonWidgetContainer.layout = QStackedLayout(self.buttonWidgetContainer)\r\n        self.buttonWidgetContainer.setMinimumSize(250,150)\r\n        self.buttonWidgetContainer.setMinimumSize(250,150)\r\n        #self.buttonWidgetContainer.setStyleSheet( \"margin-left: 20px -40px; background: #4B6E74; border: 1px solid black; border-radius: 24px;\")\r\n        self.button_Play = QLabel()\r\n        self.button_Play.layout = QStackedLayout(self.button_Play)\r\n        self.button_Play.setStyleSheet(\r\n            \"margin-left: 20px -40px; background: #4B6E74; border: 1px solid black; border-radius: 24px;\")\r\n        #self.button_Play.setStyleSheet(\r\n        #    \"margin-left: 20px -40px; background: #4B6E74;\")\r\n        #self.button_Play.setStyleSheet(\r\n        #    \"background: #4B6E74\")\r\n        self.button_Play.setMinimumSize(250, 150)\r\n        self.button_Play.setMaximumSize(250, 150)\r\n        self.DEFAULT_WIDTH = self.button_Play.width()\r\n        self.DEFAULT_HEIGTH = self.button_Play.height()\r\n        self.button_Play.setFont(self.fontA)\r\n        self.button_Play.setText(\"Start Pong Game\")\r\n        #self.button_Play.layout = QVBoxLayout()\r\n\r\n        self.loading_label = QLabel()\r\n        #self.loading_label.width = 150\r\n        #self.loading_label.height = 250\r\n        self.loading_label.setVisible(False)\r\n        self.loading_label.setMaximumSize(50, 150)\r\n        self.loading_label.setMinimumSize(50, 150)\r\n\r\n        self.loading_label.setStyleSheet(\r\n            \"margin-left: -2px; background: Yellow; border: 1px solid black; border-radius: 24px;\")\r\n        #self.buttonWidgetContainer.layout.addWidget(self.loading_label)\r\n        #self.buttonWidgetContainer.layout.addWidget(self.button_Play)\r\n        self.button_Play.layout.addWidget(self.loading_label)\r\n        # Add the two \"buttons\"\r\n        self.inner_vbox_label_container.layout.addWidget(self.button_Opinion)\r\n        self.inner_vbox_label_container.setStyleSheet('background-color: blue')\r\n\r\n        #self.inner_vbox_label_container.layout.addWidget(self.buttonWidgetContainer)\r\n\r\n        # Adds the inner box to the outer box\r\n        self.mid_label_container.layout.addWidget(self.inner_vbox_label_container)\r\n        # Chat Container\r\n        # outer box\r\n        self.outer_chat_v_label = QLabel()\r\n        self.outer_chat_v_label.layout = QVBoxLayout(self.outer_chat_v_label)\r\n        self.outer_chat_v_label.setStyleSheet(\r\n            \"overflow: hidden;border-radius: 25px; background: #F7AF9D; color: black;\")\r\n        # inner box\r\n        self.inner_chat_label = QLabel()\r\n        self.inner_chat_label.setText(\r\n            \"Lorem ipsum dolor sit amet, \\nconsetetur sadipscing elitr, \\nsed diam nonumy eirmod tempor invidunt \\nut labore et dolore magna aliquyam \\nerat, sed diam voluptua.\")\r\n        self.inner_chat_label.setStyleSheet(\r\n            \"float: left; left: 20px; padding-right: opx; border-radius: 25px; background: #EBEFF0; color: black;\")\r\n        self.inner_chat_label.setMinimumWidth(800)\r\n\r\n        # set the QScrollArea\r\n        self.scrollArea = QtGui.QScrollArea()\r\n        self.scrollArea.setGeometry(QtCore.QRect(10, 10, 100, 100))\r\n        self.scrollArea.setWidgetResizable(True)\r\n        self.scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        self.scrollArea.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\r\n        self.scrollArea.setWidget(self.inner_chat_label)\r\n\r\n        # add the chat and the scroll area\r\n        self.outer_chat_v_label.setMaximumSize(300,400)\r\n        self.inner_vbox_label_container.setMaximumSize(300,600)\r\n        #self.mid_label_container.setStyleSheet(\"background: #EBEFF0;\")\r\n        self.mid_label_container.setMaximumHeight(400)\r\n\r\n\r\n\r\n        self.inner_chat_label.setFont(self.fontA)\r\n        # Adds the inner box to the outer box\r\n        self.outer_chat_v_label.layout.addWidget(self.scrollArea)\r\n        # Adds the chat to the midd label container\r\n        self.mid_label_container.layout.addWidget(self.outer_chat_v_label)\r\n\r\n    def load(self, i):\r\n        self.loading_label.setMaximumSize(int(self.DEFAULT_WIDTH / 100 * i), self.DEFAULT_HEIGTH)\r\n        self.loading_label.setVisible(True)\r\n\r\n    def reset_load(self):\r\n        self.loading_label.setMaximumSize(0, 0)\r\n        self.loading_label.setVisible(False)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/de.hshl.uc/src/user_interface/startWindow.py b/de.hshl.uc/src/user_interface/startWindow.py
--- a/de.hshl.uc/src/user_interface/startWindow.py	(revision f60f55b65de3e5a25c1df81acaf2ae03c3ade0c9)
+++ b/de.hshl.uc/src/user_interface/startWindow.py	(date 1655666854840)
@@ -46,19 +46,17 @@
         # Info Label
         self.info_Label_Container = QLabel()
         self.info_Label_Container.setStyleSheet(
-            "margin: 20px 40px; border-radius: 25px; background: #8BC1E9; color: black;")
+            "border-radius: 25px; background: #8BC1E9; color: black;")
         # self.info_Label_Container.setMaximumHeight(400)
         self.info_Label_Container.setFont(self.fontA)
         # self.info_Label_Container.setMaximumSize(100, 400)
         self.info_Label_Container.setAutoFillBackground(True)
         # self.info_Label_Container.setStyleSheet("""background: #ebef00;""")
-        # date and temp vBox
+        # date and temperature vBox
         self.clock_temp_vbox = QLabel()
         self.clock_temp_vbox.layout = QVBoxLayout(self.clock_temp_vbox)
 
-
-
-        # Get Date and Time
+        # get Date and Time
         timezone = pytz.timezone('Europe/Berlin')
         now = datetime.now(timezone)
         now.astimezone()
@@ -89,7 +87,7 @@
         self.clock_label = QLabel()
         self.clock_label.setText(str(time))
         self.clock_label.setAlignment(QtCore.Qt.AlignCenter)
-        # self.clock_label.setMinimumWidth(400)
+        #self.clock_label.setMinimumWidth(400)
         self.clock_label.setFont(self.fontB)
         self.clock_label.setStyleSheet("margin-bottom: 0px; color: white")
 
@@ -104,9 +102,7 @@
         # -273.15 weil Kelvin zu Celsius
         print("hier muss es hin: " + str(int(data["main"]["temp"] - (273.15))))
 
-
-
-        # Temp
+        # temperature
         self.temp_label = QLabel()
         self.temp_label.setText(str(int(data["main"]["temp"] - (273.15))) + "°C")
         self.temp_label.setAlignment(QtCore.Qt.AlignCenter)
@@ -124,7 +120,7 @@
         self.clock_temp_vbox.setMinimumWidth(800)
         # self.clock_temp_vbox.setStyleSheet("overflow: hidden;border-radius: 25px; background: #F7AF9D; color: black;")
 
-        # Hbox
+        # HBox
         self.mid_label_container = QLabel()
         self.mid_label_container.layout = QHBoxLayout(self.mid_label_container)
         self.mid_label_container.setMaximumHeight(100)
@@ -133,13 +129,14 @@
         self.inner_vbox_label_container.setMaximumSize(200, 200)
         self.inner_vbox_label_container.layout = QVBoxLayout(self.inner_vbox_label_container)
         self.inner_vbox_label_container.setAlignment(QtCore.Qt.AlignCenter)
-        # Adds Buttons to the inner box
+        # Add Buttons to the inner box
         self.button_Opinion = QPushButton('Meinungsumfrage', self.inner_vbox_label_container)
         self.button_Opinion.setStyleSheet(
             "margin-left: 20px 40px; background-color: #B28BBC; border-style: thin; border-color: black; border-width: 5px; border-radius: 24px;")
         self.button_Opinion.setMinimumSize(200, 200)
         self.button_Opinion.setMaximumSize(200, 200)
         self.button_Opinion.setFont(self.fontA)
+        # turned QPushButton button_Play to a QLabel
         #self.button_Play = QPushButton('Spielesammlung', self.inner_vbox_label_container)
         self.buttonWidgetContainer = QLabel()
         self.buttonWidgetContainer.layout = QStackedLayout(self.buttonWidgetContainer)
@@ -149,7 +146,7 @@
         self.button_Play = QLabel()
         self.button_Play.layout = QStackedLayout(self.button_Play)
         self.button_Play.setStyleSheet(
-            "margin-left: 20px -40px; background: #4B6E74; border: 1px solid black; border-radius: 24px;")
+            "background: #4B6E74; border: 1px solid black; border-radius: 24px;")
         #self.button_Play.setStyleSheet(
         #    "margin-left: 20px -40px; background: #4B6E74;")
         #self.button_Play.setStyleSheet(
@@ -191,12 +188,13 @@
         # inner box
         self.inner_chat_label = QLabel()
         self.inner_chat_label.setText(
-            "Lorem ipsum dolor sit amet, \nconsetetur sadipscing elitr, \nsed diam nonumy eirmod tempor invidunt \nut labore et dolore magna aliquyam \nerat, sed diam voluptua.")
+            "Lorem ipsum dolor sit amet, \nconsetetur sadipscing elitr, \nsed diam nonumy eirmod tempor invidunt \nut "
+            "labore et dolore magna aliquyam \nerat, sed diam voluptua.")
         self.inner_chat_label.setStyleSheet(
-            "float: left; left: 20px; padding-right: opx; border-radius: 25px; background: #EBEFF0; color: black;")
+            "background: #EBEFF0;")
         self.inner_chat_label.setMinimumWidth(800)
 
-        # set the QScrollArea
+        # setup the QScrollArea
         self.scrollArea = QtGui.QScrollArea()
         self.scrollArea.setGeometry(QtCore.QRect(10, 10, 100, 100))
         self.scrollArea.setWidgetResizable(True)
Index: de.hshl.uc/src/user_interface/pongScreen.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from PyQt5 import QtCore\r\nfrom PyQt5.QtCore import Qt, QRect\r\nfrom PyQt5.QtGui import QPalette, QPixmap\r\nfrom PyQt5.QtWidgets import QWidget, QLabel, QSizePolicy, QVBoxLayout, QPushButton, QGridLayout, QHBoxLayout\r\n\r\n\r\nclass pongScreen(QWidget):\r\n    def __init__(self):\r\n        super().__init__()\r\n        # Change the desired Resolution!\r\n        # Default:\r\n        #         w: 1920\r\n        #         h: 1080\r\n        # Beamer in use:\r\n        #         w: 1280\r\n        #         h: 750\r\n        width = 1280\r\n        height = 750\r\n        self.imageLabel = QLabel()\r\n        self.setMinimumSize(width, height)\r\n        self.setMaximumSize(width, height)\r\n        #self.imageLabel.setMinimumSize(width, height)\r\n        #self.imageLabel.setMaximumSize(width, height)\r\n        self.imageLabel.setAutoFillBackground(True)\r\n        self.imageLabel.setAlignment(Qt.AlignCenter)\r\n        self.imageLabel.setBackgroundRole(QPalette.Base)\r\n        self.imageLabel.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)\r\n        self.imageLabel.setScaledContents(True)\r\n        # Pong paddle\r\n        self.pad_01 = QLabel\r\n        # Player 2\r\n        self.pad02 = QLabel\r\n\r\n        # self.central_widget.a\r\n        self.layout = QHBoxLayout(self.imageLabel)\r\n        #self.imageLabel.layout = QHBoxLayout(self.imageLabel)\r\n        # Player 1 - Imagelabel 1 = paddle1\r\n        self.imageLabel1 = QLabel()\r\n        self.imageLabel1.setMinimumSize(10, 200)\r\n        self.imageLabel1.setMaximumSize(10, 200)\r\n        self.imageLabel1.setStyleSheet(\"background-color: #00b000;\")\r\n        #self.imageLabel1.setGeometry(QRect(10, 200, 10, 400))\r\n        self.imageLabel1.setAutoFillBackground(True)\r\n        # Player 2 - Imagelabel 2 = paddle2\r\n        self.imageLabel2 = QLabel()\r\n        self.imageLabel2.setMinimumSize(10, 200)\r\n        self.imageLabel2.setMaximumSize(10, 200)\r\n        self.imageLabel2.setStyleSheet(\"background-color: red;\")\r\n        #self.imageLabel2.setGeometry(QRect(1270, 200, 10, 400))\r\n        self.imageLabel2.setAutoFillBackground(True)\r\n        # Ball - Imagelabel 3 = Ball\r\n        self.imageLabel3 = QLabel()\r\n        self.imageLabel3.move(100, 100)\r\n        self.imageLabel3.resize(30, 30)\r\n        self.imageLabel3.setMaximumSize(30, 30)\r\n        self.imageLabel3.setAutoFillBackground(True)\r\n        self.imageLabel3.setStyleSheet(\"border: 3px solid #4447e3; border-radius: 15px; background-color: #3032b3;\")\r\n\r\n        # Scorelabel left\r\n        self.scoreLeft = QLabel('0')\r\n        self.scoreLeft.setMinimumSize(30, 50)\r\n        self.scoreLeft.setMaximumSize(30, 50)\r\n        self.scoreLeft.setStyleSheet(\"background-color: white; color: black; font-size: 30px; padding: 1px;\")\r\n        # Scorelabel right\r\n        self.scoreRight = QLabel('0')\r\n        self.scoreRight.setMinimumSize(30, 50)\r\n        self.scoreRight.setMaximumSize(30, 50)\r\n        self.scoreRight.setStyleSheet(\"background-color: white; color: black; font-size: 30px; padding: 1px;\")\r\n\r\n\r\n        #Bande oben\r\n        self.bandeOben = QLabel()\r\n        self.bandeOben.setMinimumSize(width, 10)\r\n        self.bandeOben.setMaximumSize(width, 10)\r\n        self.bandeOben.setAutoFillBackground(True)\r\n        self.bandeOben.setVisible(False)\r\n        # Bande unten\r\n        self.bandeUnten = QLabel()\r\n        self.bandeUnten.setMinimumSize(width, 10)\r\n        self.bandeUnten.setMaximumSize(width, 10)\r\n        self.bandeUnten.setAutoFillBackground(True)\r\n        self.bandeUnten.setVisible(False)\r\n        # Tor links\r\n        self.torLeft = QLabel()\r\n        self.torLeft.setMinimumSize(10, height)\r\n        self.torLeft.setMaximumSize(10, height)\r\n        self.torLeft.setAutoFillBackground(True)\r\n        #self.torleft.setVisible(False)\r\n        # Tor rechts\r\n        self.torRight = QLabel()\r\n        self.torRight.setMinimumSize(10, height)\r\n        self.torRight.setMaximumSize(10, height)\r\n        self.torRight.setAutoFillBackground(True)\r\n        #self.torRight.setVisible(False)\r\n\r\n\r\n        self.imageLabelRect = QtCore.QRectF(100, 100, 20, 20)\r\n        # self.paint = QPainter(self.imageLabelRect)\r\n        # ball\r\n        self.pixmap = QPixmap(100, 100)\r\n        self.pixmap.fill(Qt.transparent)\r\n\r\n\r\n        self.imageLabel4 = QLabel\r\n        # self.imageLabel4.setPixmap(self.imageLabel2)\r\n\r\n        # Adds paddles to the main image label\r\n        #        self.imageLabel.setPixmap(self.pixmap_item)\r\n        self.button_movie = QPushButton('Start Movie')\r\n        self.imageLabel.layout().addWidget(self.imageLabel1)\r\n        self.imageLabel.layout().addWidget(self.imageLabel3)\r\n        self.imageLabel.layout().addWidget(self.imageLabel2)\r\n        self.imageLabel.layout().addWidget(self.bandeOben)\r\n        self.imageLabel.layout().addWidget(self.bandeUnten)\r\n        self.imageLabel.layout().addWidget(self.torLeft)\r\n        self.imageLabel.layout().addWidget(self.torRight)\r\n        self.imageLabel.layout().addWidget(self.scoreLeft)\r\n        self.imageLabel.layout().addWidget(self.scoreRight)\r\n        #self.bandeUnten.geometry().setX(0)\r\n       # self.bandeUnten.setGeometry(QtCore.QRect(0, 0, 0, 0))\r\n        #self.imageLabel.layout().addWidget(self.button_movie)\r\n        # self.imageLabel.layout().addWidget(self.imageLabelRect)\r\n        # self.imageLabel.setParent(self.pad)\r\n\r\n        # self.setScene(self.scene)\r\n\r\n        # self.pd = QGraphicsRectItem(1, 1, 20, 20, self.central_widget)\r\n        # self.image_view = ImageView()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/de.hshl.uc/src/user_interface/pongScreen.py b/de.hshl.uc/src/user_interface/pongScreen.py
--- a/de.hshl.uc/src/user_interface/pongScreen.py	(revision f60f55b65de3e5a25c1df81acaf2ae03c3ade0c9)
+++ b/de.hshl.uc/src/user_interface/pongScreen.py	(date 1655666854845)
@@ -68,7 +68,7 @@
         self.scoreRight.setStyleSheet("background-color: white; color: black; font-size: 30px; padding: 1px;")
 
 
-        #Bande oben
+        # Bande oben
         self.bandeOben = QLabel()
         self.bandeOben.setMinimumSize(width, 10)
         self.bandeOben.setMaximumSize(width, 10)
@@ -85,16 +85,16 @@
         self.torLeft.setMinimumSize(10, height)
         self.torLeft.setMaximumSize(10, height)
         self.torLeft.setAutoFillBackground(True)
-        #self.torleft.setVisible(False)
+        # self.torleft.setVisible(False)
         # Tor rechts
         self.torRight = QLabel()
         self.torRight.setMinimumSize(10, height)
         self.torRight.setMaximumSize(10, height)
         self.torRight.setAutoFillBackground(True)
-        #self.torRight.setVisible(False)
+        # self.torRight.setVisible(False)
 
 
-        self.imageLabelRect = QtCore.QRectF(100, 100, 20, 20)
+        self.imageLabelRect = QtCore.QRectF(100, 100, 20, 20) #ball
         # self.paint = QPainter(self.imageLabelRect)
         # ball
         self.pixmap = QPixmap(100, 100)
@@ -116,9 +116,10 @@
         self.imageLabel.layout().addWidget(self.torRight)
         self.imageLabel.layout().addWidget(self.scoreLeft)
         self.imageLabel.layout().addWidget(self.scoreRight)
-        #self.bandeUnten.geometry().setX(0)
-       # self.bandeUnten.setGeometry(QtCore.QRect(0, 0, 0, 0))
-        #self.imageLabel.layout().addWidget(self.button_movie)
+
+        # self.bandeUnten.geometry().setX(0)
+        # self.bandeUnten.setGeometry(QtCore.QRect(0, 0, 0, 0))
+        # self.imageLabel.layout().addWidget(self.button_movie)
         # self.imageLabel.layout().addWidget(self.imageLabelRect)
         # self.imageLabel.setParent(self.pad)
 
Index: de.hshl.uc/src/Socket/online/Chat/Chat_Client_V01.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pickle\r\nimport socket\r\nimport threading\r\n\r\n\r\n\r\n\r\n# Only for debug\r\n\r\n\r\n# Listening to Server and Sending Nickname\r\nclass bcolors:\r\n    HEADER = '\\033[95m'\r\n    OKBLUE = '\\033[94m'\r\n    OKCYAN = '\\033[96m'\r\n    OKGREEN = '\\033[92m'\r\n    WARNING = '\\033[93m'\r\n    FAIL = '\\033[91m'\r\n    ENDC = '\\033[0m'\r\n    BOLD = '\\033[1m'\r\n    UNDERLINE = '\\033[4m'\r\n\r\nclass chat_client:\r\n    Y = [11]\r\n    player = 'Left'\r\n    TempTupel = (player, 0)\r\n    TempChatList = [TempTupel]\r\n    packets = []\r\n    #client = \"Client\"\r\n    nickname = 'Client'\r\n    pkg = []\r\n    def __init__(self) :\r\n        # Choosing Nickname\r\n        self.nickname = 'Client: '  # input(\"Choose your nickname: \")\r\n\r\n        # Connecting To Server\r\n        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\r\n        self.client.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\r\n        self.client.connect(('34.159.99.140', 1668))\r\n        #print(self.client)\r\n        self.tuple = (1, 2)\r\n        counter = 0\r\n        self.Player = \"\"\r\n        self.serial = pickle.dumps(self.tuple)\r\n        #self.tempTupel=(self.Player,2)\r\n        #self.y = [2]\r\n\r\n    def receive(self):\r\n        while True:\r\n            try:\r\n                print(bcolors.WARNING, \"Server_____: \", bcolors.ENDC)\r\n                Y = 10\r\n                print(Y)\r\n                #print(self.client)\r\n                # Receive Message From Server\r\n                # If 'NICK' Send Nickname\r\n                print('Vor Server Receive')\r\n                message = self.client.recv(8192)\r\n                print('Vor Message decode')\r\n                message = (pickle.loads(message))\r\n                print(message)\r\n                # To-Do: Filter Mongo db message!\r\n                #print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\r\n                print('Vor Message CHAT')\r\n                print(bcolors.WARNING,\"Chat_____: \", bcolors.ENDC)\r\n                self.TempChatList = message\r\n                print(bcolors.OKBLUE, \"Chat: \", self.TempChatList,bcolors.ENDC)\r\n                print(self.TempChatList)\r\n\r\n\r\n                #packets = message\r\n                print('Vor Message decode2')\r\n                #self.pKg = packets\r\n                #print(\"SERVERPACKET: \",packets)\r\n                #self.TempTupel = message\r\n                #if len(self.pKg) != 0:\r\n                #    for tuple in packets:\r\n                #        self.TempTupel = tuple\r\n                #self.settimeout(0.050)\r\n                #self.y = message\r\n                #self.tempTupel = message\r\n                #message = self.client.recv(1024).decode('ascii')\r\n                print('Server: ', message)\r\n            except:\r\n                # Close Connection When Error\r\n                print(\"An error occured!\")\r\n                # client.close()\r\n                # break\r\n    def upadteA(self):\r\n        self.y.clear()\r\n        print(self.y)\r\n\r\n    def updateCoordinate(self, update):\r\n        self.y = update\r\n        print('Update!!!!: ',update)\r\n\r\n    def close_client(self):\r\n        self.client.close()\r\n\r\n    # Sending Messages To Server\r\n    def write(self):\r\n        while True:\r\n            message = '{}: {}'.format(self.nickname, input(''))\r\n            #self.sendcoordinate(10)\r\n            print(message)\r\n            #self.client.send(self.serial)\r\n\r\n    # message = '{}: {}'.format(nickname, input(''))\r\n    # print(message)\r\n    # client.send(serial)\r\n\r\n    def sendcoordinate(self,Player ,yCoordiante):\r\n        print('Send: ', Player ,yCoordiante)\r\n        self.Y = yCoordiante\r\n        receive_thread = threading.Thread(target=self.receive, args=())\r\n        receive_thread.start()\r\n        #print(self.Y)\r\n        playerCoordinates = (Player, yCoordiante)\r\n        serialPC = pickle.dumps(playerCoordinates)\r\n        #serialY = pickle.dumps(yCoordiante)\r\n        self.client.send(serialPC)\r\n        # Starting Threads For Listening And Writing\r\n\r\n    def main(self):\r\n\r\n        lclient = chat_client()\r\n        receive_thread = threading.Thread(target=lclient.receive, args=())\r\n        print('TEST')\r\n        receive_thread.start()\r\n\r\n        write_thread = threading.Thread(target=lclient.write(), args=())\r\n        write_thread.start()\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    c = chat_client\r\n    c.main(self=chat_client)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/de.hshl.uc/src/Socket/online/Chat/Chat_Client_V01.py b/de.hshl.uc/src/Socket/online/Chat/Chat_Client_V01.py
--- a/de.hshl.uc/src/Socket/online/Chat/Chat_Client_V01.py	(revision f60f55b65de3e5a25c1df81acaf2ae03c3ade0c9)
+++ b/de.hshl.uc/src/Socket/online/Chat/Chat_Client_V01.py	(date 1655666854850)
@@ -118,6 +118,7 @@
         playerCoordinates = (Player, yCoordiante)
         serialPC = pickle.dumps(playerCoordinates)
         #serialY = pickle.dumps(yCoordiante)
+
         self.client.send(serialPC)
         # Starting Threads For Listening And Writing
 
Index: .idea/HSHL_UC_SS22.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <sourceFolder url=\"file://$MODULE_DIR$/de.hshl.uc/src\" isTestSource=\"false\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv\" />\r\n      <excludeFolder url=\"file://$MODULE_DIR$/venv_new\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.10 (HSHL_UC_SS22)\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n  <component name=\"PyDocumentationSettings\">\r\n    <option name=\"format\" value=\"PLAIN\" />\r\n    <option name=\"myDocStringFormat\" value=\"Plain\" />\r\n  </component>\r\n  <component name=\"PyNamespacePackagesService\">\r\n    <option name=\"namespacePackageFolders\">\r\n      <list>\r\n        <option value=\"$MODULE_DIR$/de.hshl.uc/src/recognition\" />\r\n        <option value=\"$MODULE_DIR$/de.hshl.uc/src/model\" />\r\n        <option value=\"$MODULE_DIR$/de.hshl.uc/src/user_interface\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/HSHL_UC_SS22.iml b/.idea/HSHL_UC_SS22.iml
--- a/.idea/HSHL_UC_SS22.iml	(revision f60f55b65de3e5a25c1df81acaf2ae03c3ade0c9)
+++ b/.idea/HSHL_UC_SS22.iml	(date 1655666854854)
@@ -6,7 +6,7 @@
       <excludeFolder url="file://$MODULE_DIR$/venv" />
       <excludeFolder url="file://$MODULE_DIR$/venv_new" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.10 (HSHL_UC_SS22)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.10" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="PyDocumentationSettings">
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10 (HSHL_UC_SS22)\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision f60f55b65de3e5a25c1df81acaf2ae03c3ade0c9)
+++ b/.idea/misc.xml	(date 1655666854890)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (HSHL_UC_SS22)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
